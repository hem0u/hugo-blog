[{"content":"Technical Selection Since there are more parts that I want to design myself, the tech stack is HTML, CSS, and JavaScript, and I\u0026rsquo;m going to rub a personal website out myself\n这篇文章记录一切在我搭建个人网站时所需要使用的知识，和实现过程\n前期准备 编程软件 我选择的软件为vscode，详细的安装和配置可以参考这个文章（这是一个跳转链接）\n以下为我安装的几个插件：\nAuto Rename Tag：在你修改开始标签时，自动将结束标签修改为与开始标签一致的插件\nLive Server：右键html文件，选择Open with Live Server 打开一个实时预览文件效果的网页\n字体、主题色的选择 字体\n在搭建我们的网站前，可以选择一个喜欢的字体，作为我们网站的主要字体\n我选择的字体为阿里巴巴惠普体，这是一个免费的可商用字体\n主题色\n可以在colorhunt这个网站中，选择喜欢的颜色搭配，作为我们网站的主题色\n这是我选择的主题色，可供参考\n学习三大件 因为虽然之前学过一些有关三大件（HTML、CSS、JavaScript）的基础知识，但是已经忘记的差不多了，所以决定从头学起，以下是我学习的一些资料：\n官方学习文档\n3小时前端入门教程（HTML+CSS+JS）\n","date":"2025-05-02T21:06:13+08:00","permalink":"https://hem0u.github.io/hugo-blog/p/personal-website-construction/","title":"Personal website construction"},{"content":"因为对AI比较的感兴趣，所以打算从AI Infra（人工智能基础设施）入手，以下是我的学习路线：\n阶段 1：计算机科学与数学基础 目标 掌握编程、算法、操作系统和数学基础，为后续分布式系统和机器学习打基础。\n核心内容 第1-3天：Python基础速成\nPython（ML 主流语言）：掌握 NumPy、Pandas、多线程/多进程。 目标：能读懂PyTorch代码 只学这些： 变量/循环/函数 列表/字典/切片操作 类的基本语法（__init__, self） 资源：Python官方教程（3小时版）（跳过GUI、网络编程） C++（高性能计算）：理解内存管理、指针、STL。 推荐资源：《Effective C++》（书）、C++ Core Guidelines Bash/Shell：Linux 环境下的脚本编写。 2.数据结构与算法\n重点：哈希表、树（B+树）、图算法、动态规划。 推荐资源： 书籍：《算法导论》（CLRS） 课程：Stanford CS161: Design and Analysis of Algorithms 刷题：LeetCode（至少 200 题） 3.操作系统\n进程/线程调度、虚拟内存、文件系统、IO 模型（epoll）。 推荐资源： 书籍：《Operating Systems: Three Easy Pieces》（免费在线版） 课程：MIT 6.S081: Operating Systems Engineering（基于 RISC-V 实践） 4.计算机网络\nTCP/IP 协议栈、HTTP/2、gRPC、WebSocket。 推荐资源： 书籍：《Computer Networking: A Top-Down Approach》 课程：Stanford CS144: Introduction to Computer Networking 5.数学基础\n线性代数：矩阵分解、特征值、张量运算。 概率统计：贝叶斯定理、假设检验。 优化理论：梯度下降、凸优化。 推荐资源： 书籍：《Mathematics for Machine Learning》（剑桥大学出版） 课程：MIT 18.06: Linear Algebra 阶段 2：分布式系统与云计算 目标 掌握分布式计算、存储、调度和云原生技术，为 AI 大规模训练和部署做准备。\n核心内容 1.分布式计算框架\nMapReduce、Spark、Flink（批流一体）。 推荐资源： 书籍：《Big Data: Principles and Best Practices》 课程：UC Berkeley CS267: Distributed Systems 2.存储系统\n分布式文件系统（HDFS、S3）、数据库（PostgreSQL、MongoDB）、缓存（Redis）。 推荐资源： 书籍：《Designing Data-Intensive Applications》（DDIA，必读） 课程：CMU 15-445: Database Systems 3.资源调度与容器化\nKubernetes（K8s）、Docker、YARN。 推荐资源： 书籍：《Kubernetes in Action》 课程：Kubernetes 官方文档 4.云服务（AWS/GCP/Azure）\n学习 EC2、S3、Lambda、SageMaker（AWS）、Vertex AI（GCP）。 推荐资源： 课程：AWS Certified Machine Learning Specialty 阶段 3：机器学习与深度学习基础 目标 理解 ML/DL 核心算法，掌握 PyTorch/TensorFlow 框架。\n核心内容 1.机器学习基础\n监督/无监督学习、特征工程、模型评估。 推荐资源： 书籍：《The Elements of Statistical Learning》 课程：Andrew Ng: Machine Learning (Coursera) 2.深度学习\nCNN、RNN、Transformer、优化器（Adam、LAMB）。 推荐资源： 书籍：《Deep Learning》（花书） 课程：Fast.ai: Practical Deep Learning 3.框架实战\nPyTorch（推荐）、TensorFlow。 推荐资源： 官方教程：PyTorch Tutorials 书籍：《Deep Learning with PyTorch》 阶段 4：AI Infrastructure 核心技术 目标 掌握大规模训练、推理优化、MLOps 等 AI Infra 关键技术。\n核心内容 1.分布式训练\n数据并行（PyTorch DDP）、模型并行（Megatron-LM）、流水线并行（GPipe）。 推荐资源： 论文：《Efficient Large-Scale Language Model Training》 框架：DeepSpeed 2.模型推理优化\n量化（TensorRT）、剪枝、蒸馏。 推荐资源： 课程：NVIDIA DLI: Accelerating AI with TensorRT 3.MLOps\n特征存储（Feast）、模型监控（Evidently）、CI/CD（MLflow）。 推荐资源： 书籍：《Machine Learning Engineering》 课程：Stanford CS329S: ML Systems Design 阶段 5：前沿方向（选学） 可选方向 1.大模型 Infra\nColossalAI、vLLM、FlashAttention。 2.硬件加速\nCUDA 编程、TPU 架构。 3.Serverless ML\nAWS Lambda + SageMaker。 阶段 6：实战项目 推荐项目 使用 Kubernetes 部署分布式训练任务。 用 TensorRT 优化 ResNet 推理延迟。 复现一篇 MLSys 论文（如 《ZeRO: Memory Optimization》）。 总结 基础：编程 + 算法 + 系统。 进阶：分布式 + 云计算 + ML。 专项：训练/推理优化 + MLOps。 前沿：大模型 + 硬件加速。 保持学习的方式：\n关注 MLSys、NeurIPS、ICML 会议。 参与 开源项目（如 HuggingFace、Ray）。 订阅 AI Infra 博客（如 OpenAI Blog、DeepSpeed）。 这份路线足够详细且可执行，建议根据自身背景调整学习节奏。\n","date":"2025-04-27T18:31:21+08:00","image":"https://hem0u.github.io/hugo-blog/p/ai-infra%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/image_hu_402ecd2fb5b936a.png","permalink":"https://hem0u.github.io/hugo-blog/p/ai-infra%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/","title":"Ai Infra学习规划"},{"content":"python的环境配置 安装 python 在官网【Download Python | Python.org】进行下载，在安装时勾选Path选项 安装后可打开Windows PowerShell输入python --version进行验证，出现正确的版本号即为安装成功 pip 用于安装包与卸载包，例 pip install tqdm pip uninstall tqdm tqdm 是用于显示进度条的包，安装后可以用import tqdm调用 【e.g.】 test.py\nfrom tqdm import tqdm import time for i in tqdm(range(100)): #假设正在进行一些耗时的操作 time.sleep(0.01) pip换源\n【看】 换源的解释：\n阿里的源较稳定【 https://developer.aliyun.com/mirror/ 】 【看】 官方换源的方法：\npip config set global.index-url {source_url} #永久 pip install tqdm -i {source_url} #临时 【注】 我自己使用的方法：\n在用户文件夹下创建pip/pip.ini，写入以下内容 [global] index-url = http://mirrors.aliyun.com/pypi/simple/ [install] trusted-host=mirrors.aliyun.com 包的位置\n安装目录下的Scripts文件夹内 venv venv是创建虚拟环境，用与版本隔离(推荐在项目编写时使用虚拟环境) venv的基本命令\npython -m venv {vitualenv_name} #创建虚拟环境 source ./venv/bin/activate # Bash/ZSH(macOs + most Linux distro) ./venv/Scripts/activate #Windows 启动venv deactivate #退出venv VSCode的配置 vscode 官网 【Visual Studio Code - Code Editing. Redefined】 \u0026gt; 下载 vscode\nvscode \u0026gt; 扩展（extension tab) \u0026gt; 搜索python \u0026gt; 安装\n恭喜你，到这一步，已经可以运行.py文件了！🥳🥳\n基础语法 因为我的目标是学习python支持支撑AI Infra学习，所以会跳过一些内容的学习，目前只记录我学过的一些东西\n基本术语 function （函数）：“输入→处理→输出”的工具箱\narguments （参数）：函数的输入，将以某种方式影响函数的行为\n【e.g.】 hello.py\nprint(\u0026#34;hello world\u0026#34;) side effects （副作用）: 函数或表达式在执行过程中对外部环境产生的可观察的变化\n上面的例子中，在屏幕上打印hello world就是print函数的副作用\nbugs ：程序中的错误❌\nreturn values （返回值）：函数完成任务后，把数据传回给调用者\nvariables （变量）：存储某些值的容器\ncomments （注释）：执行程序时，会忽略注释中的内容；在python中通常用 # 包含注释\npseudocode （伪代码）：用人类语言（而不是编程语法）描述的代码逻辑\n控制流工具 if 语句 x = int(input(\u0026#34;Please enter an integer: \u0026#34;)) if x \u0026lt; 0: x = 0 print(\u0026#39;Negative changed to zero\u0026#39;) elif x == 0: print(\u0026#39;Zero\u0026#39;) elif x == 1: print(\u0026#39;Single\u0026#39;) else: print(\u0026#39;More\u0026#39;) 可有零个或多个 elif 部分，else 部分也是可选的。elif 是else if的缩写，这一点与C++不同\nfor语句 Python上的for语句与C中的for也有很大不同，列表或字符串等任意序列的元素上迭代，按它们在序列中出现的顺序。 例如：\n# 度量一些字符串： words = [\u0026#39;cat\u0026#39;, \u0026#39;window\u0026#39;, \u0026#39;defenestrate\u0026#39;] for w in words: print(w, len(w)) 在遍历一个集合（比如列表、字典）时，直接边遍历边修改它容易出错。更稳妥的做法是：先复制一份用来遍历，或者新建一个集合来存放修改后的结果。\n# 创建示例多项集 users = {\u0026#39;Hans\u0026#39;: \u0026#39;active\u0026#39;, \u0026#39;Éléonore\u0026#39;: \u0026#39;inactive\u0026#39;, \u0026#39;景太郎\u0026#39;: \u0026#39;active\u0026#39;} # 策略：迭代一个副本 for user, status in users.copy().items(): if status == \u0026#39;inactive\u0026#39;: del users[user] # 策略：创建一个新多项集 active_users = {} for user, status in users.items(): if status == \u0026#39;active\u0026#39;: active_users[user] = status range()函数 内置函数 range() 用于生成等差数列：\nfor i in range(5): print(i) 生成的序列默认从0开始，绝不会包括给定的终止值；range(10) 生成 10 个值——长度为 10 的序列的所有合法索引。range 可以不从 0 开始，且可以按给定的步长递增（即使是负数步长）：\nlist(range(5, 10)) list(range(0, 10, 3)) list(range(-10, -100, -30)) 要按索引迭代序列，可以组合使用 range() 和 len()：\na = [\u0026#39;Mary\u0026#39;, \u0026#39;had\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;little\u0026#39;, \u0026#39;lamb\u0026#39;] for i in range(len(a)): print(i, a[i]) 不过大多数情况下 enumerate() 函数很方便，详见 循环的技巧。\n如果直接打印一个 range 会发生意想不到的事情：\nrange(10) range() 返回的对象在很多方面和列表的行为一样，但其实它和列表不一样。该对象只有在被迭代时才一个一个地返回所期望的列表项，并没有真正生成过一个含有全部项的列表，从而节省了空间。\n这种对象称为可迭代对象 iterable，适合作为需要获取一系列值的函数或程序构件的参数。for 语句就是这样的程序构件；以可迭代对象作为参数的函数例如 sum()：\nsum(range(4)) # 0 + 1 + 2 + 3 break 和 continue 语句 break 语句将跳出最近的一层 for 或 while 循环:\nfor n in range(2, 10): for x in range(2, n): if n % x == 0: print(f\u0026#34;{n} equals {x} * {n//x}\u0026#34;) break continue 语句将继续执行循环的下一次迭代:\nfor num in range(2, 10): if num % 2 == 0: print(f\u0026#34;Found an even number {num}\u0026#34;) continue print(f\u0026#34;Found an odd number {num}\u0026#34;) 循环的 else 子句 在 for 或 while 循环中 break 语句可能对应一个 else 子句。 如果循环在未执行 break 的情况下结束，else 子句将会执行。\n在 for 循环中，else 子句会在循环完整执行之后，即未执行 break 的情况下被执行。\n在 while 循环中，它会在循环条件变为假值后执行。\n在这两类循环中，当在循环被 break 终结时 else 子句 不会 被执行。 当然，其他提前结束循环的方式，如 return 或是引发异常，也会跳过 else 子句的执行。\n下面的搜索质数的 for 循环就是一个例子：\nfor n in range(2, 10): for x in range(2, n): if n % x == 0: print(n, \u0026#39;equals\u0026#39;, x, \u0026#39;*\u0026#39;, n//x) break else: # 循环到底未找到一个因数 print(n, \u0026#39;is a prime number\u0026#39;) （ 仔细看：其中 else 子句属于内层 for 循环，而 不属于 if 语句。）\n当配合循环使用时，else 子句更像是 try 语句的 else 子句而不像 if 语句的相应子句：一个 try 语句的 else 子句会在未发生异常时运行，而一个循环的 else 子句会在未发生 break 时运行。 有关 try 语句和异常的详情，请参阅 异常的处理。\npass 语句 pass 语句不执行任何动作。语法上需要一个语句，但程序毋需执行任何动作时，可以使用该语句。例如：\nwhile True: pass # 无限等待键盘中断 (Ctrl+C) 这常用于创建一个最小的类：\nclass MyEmptyClass: pass pass 还可用作函数或条件语句体的占位符，让你保持在更抽象的层次进行思考。pass 会被默默地忽略：\ndef initlog(*args): pass # 记得实现这个！ match 语句 match 语句接受一个表达式并把它的值与一个或多个 case 块给出的一系列模式进行比较。这表面上像 C、Java 或 JavaScript（以及许多其他程序设计语言）中的 switch 语句，但其实它更像 Rust 或 Haskell 中的模式匹配。只有第一个匹配的模式会被执行，并且它还可以提取值的组成部分（序列的元素或对象的属性）赋给变量。\n最简单的形式是将一个主语值与一个或多个字面值进行比较：\ndef http_error(status): match status: case 400: return \u0026#34;Bad request\u0026#34; case 404: return \u0026#34;Not found\u0026#34; case 418: return \u0026#34;I\u0026#39;m a teapot\u0026#34; case _: return \u0026#34;Something\u0026#39;s wrong with the internet\u0026#34; 注意最后一个代码块：“变量名” _ 被作为 通配符 并必定会匹配成功。如果没有 case 匹配成功，则不会执行任何分支。\n你可以用 | （“或”）将多个字面值组合到一个模式中：\ncase 401 | 403 | 404: return \u0026#34;Not allowed\u0026#34; 形如解包赋值的模式可被用于绑定变量：\n# point 是一个 (x, y) 元组 match point: case (0, 0): print(\u0026#34;Origin\u0026#34;) case (0, y): print(f\u0026#34;Y={y}\u0026#34;) case (x, 0): print(f\u0026#34;X={x}\u0026#34;) case (x, y): print(f\u0026#34;X={x}, Y={y}\u0026#34;) case _: raise ValueError(\u0026#34;Not a point\u0026#34;) 请仔细学习此代码！第一个模式有两个字面值，可视为前述字面值模式的扩展。接下来的两个模式结合了一个字面值和一个变量，变量 绑定 了来自主语（point）的一个值。第四个模式捕获了两个值，使其在概念上与解包赋值 (x, y) = point 类似。\n如果用类组织数据，可以用“类名后接一个参数列表”这种很像构造器的形式，把属性捕获到变量里：\nclass Point: def __init__(self, x, y): self.x = x self.y = y def where_is(point): match point: case Point(x=0, y=0): print(\u0026#34;Origin\u0026#34;) case Point(x=0, y=y): print(f\u0026#34;Y={y}\u0026#34;) case Point(x=x, y=0): print(f\u0026#34;X={x}\u0026#34;) case Point(): print(\u0026#34;Somewhere else\u0026#34;) case _: print(\u0026#34;Not a point\u0026#34;) 一些内置类（如 dataclass）为属性提供了一个顺序，此时，可以使用位置参数。自定义类可通过在类中设置特殊属性 __match_args__，为属性指定其在模式中对应的位置。若设为 (\u0026ldquo;x\u0026rdquo;, \u0026ldquo;y\u0026rdquo;)，则以下模式相互等价（且都把属性 y 绑定到变量 var）：\nPoint(1, var) Point(1, y=var) Point(x=1, y=var) Point(y=var, x=1) 建议这样来阅读一个模式——通过将其视为赋值语句等号左边的一种扩展形式，来理解各个变量被设为何值。match 语句只会为单一的名称（如上面的 var）赋值，而不会赋值给带点号的名称（如 foo.bar）、属性名（如上面的 x= 和 y=）和类名（是通过其后的 \u0026ldquo;(\u0026hellip;)\u0026rdquo; 来识别的，如上面的 Point）。\n模式可以任意嵌套。举例来说，如果我们有一个由 Point 组成的列表，且 Point 添加了 __match_args__ 时，我们可以这样来匹配它：\nclass Point: __match_args__ = (\u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;) def __init__(self, x, y): self.x = x self.y = y match points: case []: print(\u0026#34;No points\u0026#34;) case [Point(0, 0)]: print(\u0026#34;The origin\u0026#34;) case [Point(x, y)]: print(f\u0026#34;Single point {x}, {y}\u0026#34;) case [Point(0, y1), Point(0, y2)]: print(f\u0026#34;Two on the Y axis at {y1}, {y2}\u0026#34;) case _: print(\u0026#34;Something else\u0026#34;) 我们可以为模式添加 if 作为守卫子句。如果守卫子句的值为假，那么 match 会继续尝试匹配下一个 case 块。注意是先将值捕获，再对守卫子句求值：\nmatch point: case Point(x, y) if x == y: print(f\u0026#34;Y=X at {x}\u0026#34;) case Point(x, y): print(f\u0026#34;Not on the diagonal\u0026#34;) 该语句的一些其它关键特性：\n与解包赋值类似，元组和列表模式具有完全相同的含义并且实际上都能匹配任意序列，区别是它们不能匹配迭代器或字符串。\n序列模式支持扩展解包：[x, y, *rest] 和 (x, y, *rest) 和相应的解包赋值做的事是一样的。接在 * 后的名称也可以为 _，所以 (x, y, *_) 匹配含至少两项的序列，而不必绑定剩余的项。\n映射模式：{\u0026quot;bandwidth\u0026quot;: b, \u0026quot;latency\u0026quot;: l} 从字典中捕获 \u0026quot;bandwidth\u0026quot; 和 \u0026quot;latency\u0026quot; 的值。额外的键会被忽略，这一点与序列模式不同。**rest 这样的解包也支持。（但 **_ 将会是冗余的，故不允许使用。）\n使用 as 关键字可以捕获子模式：\ncase (Point(x1, y1), Point(x2, y2) as p2): ... 将把输入中的第二个元素捕获为 p2 （只要输入是包含两个点的序列）\n大多数字面值是按相等性比较的，但是单例对象 True、False 和 None 则是按 id 比较的。\n模式可以使用具名常量。它们必须作为带点号的名称出现，以防止它们被解释为用于捕获的变量：\nfrom enum import Enum class Color(Enum): RED = \u0026#39;red\u0026#39; GREEN = \u0026#39;green\u0026#39; BLUE = \u0026#39;blue\u0026#39; color = Color(input(\u0026#34;Enter your choice of \u0026#39;red\u0026#39;, \u0026#39;blue\u0026#39; or \u0026#39;green\u0026#39;: \u0026#34;)) match color: case Color.RED: print(\u0026#34;I see red!\u0026#34;) case Color.GREEN: print(\u0026#34;Grass is green\u0026#34;) case Color.BLUE: print(\u0026#34;I\u0026#39;m feeling the blues :(\u0026#34;) 更详细的说明和更多示例，可参阅以教程格式撰写的 PEP 636。\n定义函数 下列代码创建一个可以输出限定数值内的斐波那契数列函数：\ndef fib(n): # 打印小于 n 的斐波那契数列 \u0026#34;\u0026#34;\u0026#34;Print a Fibonacci series less than n.\u0026#34;\u0026#34;\u0026#34; a, b = 0, 1 while a \u0026lt; n: print(a, end=\u0026#39; \u0026#39;) a, b = b, a+b print() # 现在调用我们刚定义的函数： fib(2000) 定义 函数使用关键字 def，后跟函数名与括号内的形参列表。函数语句从下一行开始，并且必须缩进。\n函数内的第一条语句是字符串时，该字符串就是文档字符串，也称为 docstring，详见 文档字符串。利用文档字符串可以自动生成在线文档或打印版文档，还可以让开发者在浏览代码时直接查阅文档；Python 开发者最好养成在代码中加入文档字符串的好习惯。\n函数在 执行 时使用函数局部变量符号表，所有函数变量赋值都存在局部符号表中；引用变量时，首先，在局部符号表里查找变量，然后，是外层函数局部符号表，再是全局符号表，最后是内置名称符号表。因此，尽管可以引用全局变量和外层函数的变量，但最好不要在函数内直接赋值（除非是 global 语句定义的全局变量，或 nonlocal 语句定义的外层函数变量）。\n在调用函数时会将实际参数（实参）引入到被调用函数的局部符号表中；因此，实参是使用 按值调用 来传递的（其中的 值 始终是对象的 引用 而不是对象的值）。 [1] 当一个函数调用另外一个函数时，会为该调用创建一个新的局部符号表。\n函数定义在当前符号表中把函数名与函数对象关联在一起。解释器把函数名指向的对象作为用户自定义函数。还可以使用其他名称指向同一个函数对象，并访问访该函数：\nfib \u0026lt;function fib at 10042ed0\u0026gt; f = fib f(100) 如果你用过其他语言，你可能会认为 fib 不是函数而是一个过程，因为它没有返回值。 事实上，即使没有 return 语句的函数也有返回值，尽管这个值可能相当无聊。 这个值被称为 None (是一个内置名称)。 通常解释器会屏蔽单独的返回值 None。 如果你确有需要可以使用 print() 查看它:\nfib(0) print(fib(0)) 编写不直接输出斐波那契数列运算结果，而是返回运算结果列表的函数也非常简单：\ndef fib2(n): # 返回斐波那契数组直到 n \u0026#34;\u0026#34;\u0026#34;Return a list containing the Fibonacci series up to n.\u0026#34;\u0026#34;\u0026#34; result = [] a, b = 0, 1 while a \u0026lt; n: result.append(a) # 见下 a, b = b, a+b return result f100 = fib2(100) # 调用它 f100 # 输出结果 本例也新引入了一些 Python 功能：\nreturn 语句返回函数的值。return 语句不带表达式参数时，返回 None。函数执行完毕退出也返回 None。 语句 result.append(a) 调用了列表对象 result 的 方法。 方法是‘从属于’对象的函数，其名称为 obj.methodname，其中 obj 是某个对象（可以是一个表达式），methodname 是由对象的类型定义的方法名称。 不同的类型定义了不同的方法。 不同的类型的方法可以使用相同的名称而不会产生歧义。 （使用 类 可以定义自己的对象类型和方法，参见 类。） 在示例中显示的方法 append() 是由列表对象定义的；它会在列表的末尾添加一个新元素。 在本例中它等同于 result = result + [a]，但效率更高。 函数定义详解 默认值参数 为参数指定默认值是非常有用的方式。调用函数时，可以使用比定义时更少的参数，例如：\ndef ask_ok(prompt, retries=4, reminder=\u0026#39;Please try again!\u0026#39;): while True: reply = input(prompt) if reply in {\u0026#39;y\u0026#39;, \u0026#39;ye\u0026#39;, \u0026#39;yes\u0026#39;}: return True if reply in {\u0026#39;n\u0026#39;, \u0026#39;no\u0026#39;, \u0026#39;nop\u0026#39;, \u0026#39;nope\u0026#39;}: return False retries = retries - 1 if retries \u0026lt; 0: raise ValueError(\u0026#39;invalid user response\u0026#39;) print(reminder) 参考资料\nPython 教程 — Python 3.13.3 文档\n","date":"2025-04-26T15:40:47+08:00","image":"https://hem0u.github.io/hugo-blog/p/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_hu_4e3d22aee7ecd153.png","permalink":"https://hem0u.github.io/hugo-blog/p/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Python学习笔记"},{"content":"","date":"2025-04-25T17:32:44+08:00","permalink":"https://hem0u.github.io/hugo-blog/p/test/","title":"Test"},{"content":"Hello World 你好\n","date":"2025-04-25T15:54:09+08:00","permalink":"https://hem0u.github.io/hugo-blog/p/myfirstblog/","title":"MyFirstBlog"}]